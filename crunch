#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (C) 2011 Chris Jerdonek.  All rights reserved.
#
"""

YAML CONFIG FILE:

Leave the "finalists" value empty if the contest was decided in the first
round.  For example:

  - label: D2
    input_data: D02
    winner: "Michela Alioto-Pier"
    finalists:

TODO: complete this.

"""

from datetime import datetime
import logging
import os
import sys

from cruncher.argparser import create_argparser
from cruncher.ballot_analyzer import BallotAnalyzer
from cruncher import common
from cruncher import downloading
from cruncher.input_format import parse_input_format
from cruncher.parser import BallotParser, MasterParser
from cruncher.reporter import Reporter
from cruncher.stats import Stats


_log = logging.getLogger(__name__)


ENCODING_OUTPUT_FILE = 'utf-8'

STATS_HEADER = """\
RCV RESULTS KEY

Total:         total number of ballots, including undervotes.

Voted:         number of ballots with at least one ranking marked (or overvoted).
Undervoted:    total minus voted.

N-Candidate:   number of voted ballots with N valid distinct candidate rankings.
               A valid ranking is a ranking not preceded by an overvote.
               For example, the 0-Distinct ballots are the first-round
               overvotes, i.e. the voted ballots whose first marked ranking
               is an overvote.

Has overvote:  number of ballots with an overvoted ranking at some ranking.
Has duplicate: number of ballots with the same candidate marked more than once.
Has skipped:   number of ballots with an unmarked ranking before a marked ranking.
Irregular:     number of voted ballots with at least one of the following:
               an overvote, a duplicate candidate, or a skipped ranking (see
               above for descriptions).  Note that these categories are not
               mutually exclusive, for example an unmarked ranking followed by
               an overvoted ranking.

R1-Overvotes:  number of ballots counting as an overvote in the first round.


"""

# TODO: overview of final round (percent of continuing first round, etc).
#       Include "adjusted final round percentage."
# TODO: html encode report.

def configure_logging(logging_level=None):
    """Configure logging for standard purposes.

    Args:
      logging_level: The minimum logging level to log.
                     Defaults to logging.INFO.

    """
    # If the stream does not define an "encoding" data attribute, the
    # logging module can throw an error like the following:
    #
    # Traceback (most recent call last):
    #   File "/System/Library/Frameworks/Python.framework/Versions/2.6/...
    #         lib/python2.6/logging/__init__.py", line 761, in emit
    #     self.stream.write(fs % msg.encode(self.stream.encoding))
    # LookupError: unknown encoding: unknown
    if logging_level is None:
        logging_level = logging.INFO

    # Create the handler.
    #
    # The stream is a file-like object to which to log.  The stream must
    # define an "encoding" data attribute, or else logging raises an error.
    stream = sys.stderr
    handler = logging.StreamHandler(stream)
    formatter = logging.Formatter("%(name)s: [%(levelname)s] %(message)s")
    handler.setFormatter(formatter)

    # The root logger.
    logger = logging.getLogger()

    logger.setLevel(logging_level)
    logger.addHandler(handler)

    _log.debug("Debug logging enabled.")


class BallotHandler(object):

    def __init__(self, contest, stats, undervote, overvote):
        """
        Construct an instance.

        """
        candidates = contest.candidate_ids
        winner = contest.winner_id
        finalists = contest.finalists
        non_winning_finalists = contest.non_winning_finalists

        self.analyzer = BallotAnalyzer(undervote=undervote, overvote=overvote)
        self.stats = stats

        self.winner = winner
        self.set_of_finalists = set(finalists)
        self.non_winning_finalists = non_winning_finalists
        self.non_winners = list(set(candidates) - set([winner]))

    def on_ballot(self, ballot):
        """
        Update stats based on the given ballot.

        """
        analyzer = self.analyzer
        stats = self.stats
        winner = self.winner

        stats.total += 1

        first_round = analyzer.get_first_round(ballot)

        if first_round == self.analyzer.undervote:
            stats.undervotes += 1
            return

        # Now check for various types of irregularities.
        duplicate_count = analyzer.count_duplicates(ballot)
        if duplicate_count > 1:
            stats.duplicates[duplicate_count] += 1
            has_duplicate = True
        else:
            has_duplicate = False

        has_overvote = analyzer.has_overvote(ballot)
        has_skipped = analyzer.has_skipped(ballot)

        if has_overvote:
            stats.has_overvote += 1
        if has_skipped:
            stats.has_skipped += 1
        if has_overvote or has_duplicate or has_skipped:
            stats.irregular += 1

        if first_round == self.analyzer.overvote:
            stats.first_round_overvotes += 1
            # Return since all remaining analysis needs effective choices.
            return

        effective_choices = analyzer.get_effective_choices(ballot)
        number_ranked = len(effective_choices)

        stats.add_number_ranked(first_round, number_ranked)

        for index in range(number_ranked):
            candidate = effective_choices[index]
            stats.ballot_position[candidate][index] += 1

        if number_ranked == 3 and self.set_of_finalists.isdisjoint(effective_choices):
            stats.truly_exhausted[first_round] += 1
        if winner in effective_choices:
            stats.ranked_winner[first_round] += 1
        if not self.set_of_finalists.isdisjoint(effective_choices):
            stats.ranked_finalist[first_round] += 1
        else:
            # Then no finalist is validly ranked on the ballot.
            if self.analyzer.overvote in ballot:
                stats.exhausted_by_overvote += 1
        if analyzer.did_sweep(ballot, first_round):
            stats.did_sweep[first_round] += 1

        if analyzer.beats_challengers(ballot, winner, self.non_winning_finalists):
            stats.final_round_winner_total += 1

        # Calculate condorcet pairs against winner.
        for non_winner in self.non_winners:
            did_winner_win = analyzer.beats_challenger(ballot, winner, non_winner)
            if did_winner_win is None:
                continue
            if did_winner_win:
                stats.add_condorcet_winner(winner, non_winner)
            else:
                stats.add_condorcet_winner(non_winner, winner)


def main(sys_argv):
    start_time = datetime.now()

    args = sys_argv[1:]

    parser = create_argparser()
    ns = parser.parse_args(args)

    config_path = ns.config_path
    data_dir = ns.data_dir
    output_dir = ns.output_dir
    suppress_download = ns.suppress_download

    if not os.path.exists(output_dir):
        os.mkdir(output_dir)

    configure_logging(logging.DEBUG)

    config = common.unserialize_yaml_file(config_path)

    election_label = config['election_label']
    election_name = config['election_name']

    input_format = parse_input_format(config['input_format'], suppress_download=suppress_download)

    utc_now = datetime.utcnow()
    reporter = Reporter(election_name=election_name.upper(), template_path='templates/report.mustache')

    contest_configs = config['contests']

    # Download all data before trying to process.  This simplifies certain
    # types of troubleshooting because we can turn off downloading for
    # subsequent runs.
    path_pairs = []
    for contest in contest_configs:

        contest_label = contest.get('label') or contest['source']
        winner = contest['winner']
        finalists = contest['finalists'] or []

        path_pair = input_format.get_data(election_label, contest_label, contest, data_dir)
        path_pairs.append(path_pair)

    for contest_config, path_pair in zip(contest_configs, path_pairs):

        contest_label = contest_config.get('label') or contest_config['source']
        winner = contest_config['winner']
        finalists = contest_config['finalists'] or []
        round_by_round_url = contest_config.get('url')
        master_path, ballot_path = path_pair

        master_parser = MasterParser(input_format, winner, final_candidates=finalists)
        contest = master_parser.parse(master_path)

        stats = Stats(candidates=contest.candidate_ids, winner_id=contest.winner_id)
        ballot_handler = BallotHandler(contest, stats, undervote=input_format.undervote,
            overvote=input_format.overvote)

        # Parsing the ballot file is faster without specifying an encoding.
        # The ballot file is just integers, so an encoding is not necessary.
        parser = BallotParser(input_format=input_format, on_ballot=ballot_handler.on_ballot)
        parser.process_contest(ballot_path, winner)

        download_metadata = input_format.get_download_metadata(master_path)

        reporter.add_contest(contest_label, contest, stats,
                             download_metadata=download_metadata,
                             round_by_round_url=round_by_round_url)

    datetime_local, local_tzname = common.utc_datetime_to_local_datetime_tzname(utc_now)
    report = reporter.generate(datetime_local, local_tzname)

    try:
        print report
    except UnicodeEncodeError:
        # Windows seems to have trouble with some unicode characters, e.g. the "Ó" in GASCÓN.
        _log.warn("Error printing report to console (probably because of special characters.")

    output_path = os.path.join(output_dir, "rcv_stats_%s.html" % election_label)
    common.write_to_file(report, output_path)

    print "Completed in: %s" % (datetime.now() - start_time)


if __name__ == "__main__":
    main(sys.argv)
