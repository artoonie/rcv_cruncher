#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (C) 2011 Chris Jerdonek.  All rights reserved.
#
"""

YAML CONFIG FILE:

Leave the "finalists" value empty if the contest was decided in the first
round.  For example:

  - label: D2
    input_data: D02
    winner: "Michela Alioto-Pier"
    finalists:

TODO: complete this.

"""

from datetime import datetime
import logging
import os
import sys

from cruncher.argparser import create_argparser
from cruncher.ballot_analyzer import BallotAnalyzer
from cruncher import common
from cruncher.common import find_in_map
from cruncher import downloading
from cruncher.input_format import parse_input_format
from cruncher.parser import parse_master, BallotParser, Contest
from cruncher.reporter import Reporter
from cruncher.stats import increment_dict_total, Stats


_log = logging.getLogger(__name__)


ENCODING_OUTPUT_FILE = 'utf-8'

STATS_HEADER = """\
RCV RESULTS KEY

Total:         total number of ballots, including undervotes.

Voted:         number of ballots with at least one ranking marked (or overvoted).
Undervoted:    total minus voted.

N-Candidate:   number of voted ballots with N valid distinct candidate rankings.
               A valid ranking is a ranking not preceded by an overvote.
               For example, the 0-Distinct ballots are the first-round
               overvotes, i.e. the voted ballots whose first marked ranking
               is an overvote.

Has overvote:  number of ballots with an overvoted ranking at some ranking.
Has duplicate: number of ballots with the same candidate marked more than once.
Has skipped:   number of ballots with an unmarked ranking before a marked ranking.
Irregular:     number of voted ballots with at least one of the following:
               an overvote, a duplicate candidate, or a skipped ranking (see
               above for descriptions).  Note that these categories are not
               mutually exclusive, for example an unmarked ranking followed by
               an overvoted ranking.

R1-Overvotes:  number of ballots counting as an overvote in the first round.


"""

def configure_logging(logging_level=None):
    """Configure logging for standard purposes.

    Args:
      logging_level: The minimum logging level to log.
                     Defaults to logging.INFO.

    """
    # If the stream does not define an "encoding" data attribute, the
    # logging module can throw an error like the following:
    #
    # Traceback (most recent call last):
    #   File "/System/Library/Frameworks/Python.framework/Versions/2.6/...
    #         lib/python2.6/logging/__init__.py", line 761, in emit
    #     self.stream.write(fs % msg.encode(self.stream.encoding))
    # LookupError: unknown encoding: unknown
    if logging_level is None:
        logging_level = logging.INFO

    # Create the handler.
    #
    # The stream is a file-like object to which to log.  The stream must
    # define an "encoding" data attribute, or else logging raises an error.
    stream = sys.stderr
    handler = logging.StreamHandler(stream)
    formatter = logging.Formatter("%(name)s: [%(levelname)s] %(message)s")
    handler.setFormatter(formatter)

    # The root logger.
    logger = logging.getLogger()

    logger.setLevel(logging_level)
    logger.addHandler(handler)

    _log.debug("Debug logging enabled.")


class ContestConfig(object):

    def __init__(self, data):
        self.name = data.get('name')
        self.label = data.get('label') or data['source']
        self.winner = data['winner']
        # An empty list of finalists means all candidates (no elimination).
        self.finalists = data['finalists'] or []
        self.round_by_round_url = data.get('url')

        # For certain special cases, we also need access to the original config.
        self.data = data

    def __repr__(self):
        return "<ContestConfig: %r>" % repr(self.data)


class ContestInfo(object):

    def __init__(self, contest, config, stats, ballot_handler):
        self.ballot_handler = ballot_handler
        self.config = config
        self.contest = contest
        self.stats = stats


class BallotHandler(object):

    def __init__(self, analyzer, contest, stats):
        """
        Construct an instance.

        """
        candidates = contest.candidate_ids
        winner = contest.winner_id
        finalists = contest.finalists
        non_winning_finalists = contest.non_winning_finalists

        self.analyzer = analyzer
        self.stats = stats

        self.winner = winner
        self.set_of_finalists = set(finalists)
        self.non_winning_finalists = non_winning_finalists
        self.non_winners = list(set(candidates) - set([winner]))

    def on_ballot(self, ballot):
        """
        Update stats based on the given ballot.

        """
        analyzer = self.analyzer
        stats = self.stats
        winner = self.winner

        stats.total += 1

        first_round = analyzer.get_first_round(ballot)

        if first_round == self.analyzer.undervote:
            stats.undervotes += 1
            return

        # Now check for various types of irregularities.
        duplicate_count = analyzer.count_duplicates(ballot)
        if duplicate_count > 1:
            stats.duplicates[duplicate_count] += 1
            has_duplicate = True
        else:
            has_duplicate = False

        has_overvote = analyzer.has_overvote(ballot)
        has_skipped = analyzer.has_skipped(ballot)

        if has_overvote:
            stats.has_overvote += 1
        if has_skipped:
            stats.has_skipped += 1
        if has_overvote or has_duplicate or has_skipped:
            stats.irregular += 1

        if first_round == self.analyzer.overvote:
            stats.first_round_overvotes += 1
            # Return since all remaining analysis needs effective choices.
            return

        effective_choices = analyzer.get_effective_choices(ballot)
        number_ranked = len(effective_choices)

        stats.add_number_ranked(first_round, number_ranked)

        for index in range(number_ranked):
            candidate = effective_choices[index]
            stats.ballot_position[candidate][index] += 1

        if number_ranked == 3 and self.set_of_finalists.isdisjoint(effective_choices):
            stats.truly_exhausted[first_round] += 1
        if winner in effective_choices:
            stats.ranked_winner[first_round] += 1
        if not self.set_of_finalists.isdisjoint(effective_choices):
            stats.ranked_finalist[first_round] += 1
        else:
            # Then no finalist is validly ranked on the ballot.
            if self.analyzer.overvote in ballot:
                stats.exhausted_by_overvote += 1
        if analyzer.did_sweep(ballot, first_round):
            stats.did_sweep[first_round] += 1

        if analyzer.beats_challengers(ballot, winner, self.non_winning_finalists):
            stats.final_round_winner_total += 1

        # Calculate condorcet pairs against winner.
        for non_winner in self.non_winners:
            did_winner_win = analyzer.beats_challenger(ballot, winner, non_winner)
            if did_winner_win is None:
                continue
            if did_winner_win:
                stats.add_condorcet_winner(winner, non_winner)
            else:
                stats.add_condorcet_winner(non_winner, winner)

        # Track orderings and combinations.
        increment_dict_total(stats.combinations, frozenset(effective_choices))
        increment_dict_total(stats.orderings, effective_choices)


def find_candidate_id(candidate_dict, name_to_find):
    return find_in_map(candidate_dict, name_to_find)


def get_contest_id(contest_config, contest_ids):
    """Return the contest_id for a contest_config."""
    contest_name = contest_config.name
    try:
        contest_id = contest_ids[contest_name]
    except KeyError:
        # The contest will not have a name configured if there is only one.
        try:
            assert contest_name is None
            assert len(contest_ids) == 1
        except AssertionError:
            raise Exception("contest_name=%r, contest_ids=%r" % (contest_name, contest_ids))
        contest_id = contest_ids.values()[0]
    return contest_id


def make_contest_infos(analyzer, contest_configs, contest_dict, contest_ids):
    """
    Return a dict mapping contest_id to ContestInfo object.
    """
    contest_infos = {}

    for contest_config in contest_configs:
        contest_id = get_contest_id(contest_config, contest_ids)
        contest_name, candidate_dict = contest_dict[contest_id]

        winner = contest_config.winner
        finalists = contest_config.finalists

        winner_id = find_candidate_id(candidate_dict, winner)

        finalist_ids = []
        for candidate in finalists:
            finalist_id = find_candidate_id(candidate_dict, candidate)
            finalist_ids.append(finalist_id)

        contest = Contest(contest_name, candidate_dict, winner_id, finalist_ids)
        stats = Stats(candidates=contest.candidate_ids, winner_id=contest.winner_id)
        ballot_handler = BallotHandler(analyzer, contest, stats)

        contest_info = ContestInfo(contest, contest_config, stats, ballot_handler)
        contest_infos[contest_id] = contest_info

    return contest_infos


def get_download_paths(election_label, input_format, input_config,
                       contest_configs, data_dir):
    """
    Return an iterable of (contest_configs, path_pair).
    """
    # A list of (contest_configs, dir_name, urls).
    # Each element of this list corresponds to a set of files that can
    # be independently downloaded and parsed.
    download_infos = []
    if 'single_source' in input_config:
        # Then all contests are contained in a single file.
        source = input_config['single_source']
        download_infos.append((contest_configs, "election", [source]))
    else:
        # Then each contest is contained in a separate file.

        # This can be a string or list of strings.
        election_sources = input_config['source']
        if isinstance(election_sources, str):
            election_sources = [election_sources]
        for contest_config in contest_configs:
            label = contest_config.label
            urls = [source % label for source in election_sources]
            configs = [contest_config]
            download_infos.append((configs, label, urls))

    # An iterable of (contest_configs, path_pair).
    path_infos = []
    for configs, dir_name, urls in download_infos:
        path_pair = input_format.get_data(election_label, dir_name, urls, data_dir)
        path_infos.append((configs, path_pair))

    return path_infos


def parse_download(analyzer, input_format, reporter, contest_configs, path_pair):
    master_path, ballot_path = path_pair

    # The contest_dict dictionary maps contest_id to (contest_name, candidate_dict).
    contest_dict = parse_master(input_format, master_path)
    contest_ids = {contest_dict[contest_id][0]: contest_id for contest_id in contest_dict.keys()}

    contest_infos = make_contest_infos(analyzer, contest_configs, contest_dict, contest_ids)

    parser = BallotParser(input_format=input_format, contest_infos=contest_infos)
    parser.parse_ballots(ballot_path)

    download_metadata = input_format.get_download_metadata(master_path)

    for contest_config in contest_configs:
        contest_id = get_contest_id(contest_config, contest_ids)
        contest_info = contest_infos[contest_id]
        reporter.add_contest(contest_info, download_metadata=download_metadata)


def main(sys_argv):
    start_time = datetime.now()

    args = sys_argv[1:]

    parser = create_argparser()
    ns = parser.parse_args(args)

    config_path = ns.config_path
    data_dir = ns.data_dir
    output_dir = ns.output_dir
    suppress_download = ns.suppress_download

    if not os.path.exists(output_dir):
        os.mkdir(output_dir)

    configure_logging(logging.DEBUG)

    election_config = common.unserialize_yaml_file(config_path)

    election_label = election_config['election_label']
    election_name = election_config['election_name']
    input_config = election_config['input_format']

    input_format = parse_input_format(input_config, suppress_download=suppress_download)
    analyzer = BallotAnalyzer(undervote=input_format.undervote, overvote=input_format.overvote)

    utc_now = datetime.utcnow()
    reporter = Reporter(election_name=election_name.upper(), template_path='templates/report.mustache')

    contests_config = election_config['contests']
    contest_configs = []
    for data in contests_config:
        contest_config = ContestConfig(data)
        contest_configs.append(contest_config)

    # Download all data before trying to process.  This simplifies certain
    # types of troubleshooting because we can turn off downloading for
    # subsequent runs.
    download_infos = get_download_paths(election_label, input_format, input_config,
                                        contest_configs, data_dir)
    for contest_configs, path_pair in download_infos:
        parse_download(analyzer, input_format, reporter, contest_configs, path_pair)

    datetime_local, local_tzname = common.utc_datetime_to_local_datetime_tzname(utc_now)
    report = reporter.generate(datetime_local, local_tzname)

    try:
        print report
    except UnicodeEncodeError:
        # Windows seems to have trouble with some unicode characters, e.g. the "Ó" in GASCÓN.
        _log.warn("Error printing report to console (probably because of special characters.")

    output_path = os.path.join(output_dir, "rcv_stats_%s.html" % election_label)
    common.write_to_file(report, output_path)

    print "Completed in: %s" % (datetime.now() - start_time)


if __name__ == "__main__":
    main(sys.argv)
