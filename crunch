#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (C) 2011 Chris Jerdonek.  All rights reserved.
#
"""
TODO: complete this.

"""

import calendar
import codecs
from datetime import datetime
import glob
import logging
import os
import sys
import time
import urllib
import yaml
from zipfile import ZipFile

from lib.ballot_analyzer import BallotAnalyzer
from lib.parser import MasterParser
from lib.parser import BallotParser
from lib.reporter import Reporter
from lib.stats import Stats


_log = logging.getLogger(__name__)


ENCODING_INTERNAL = 'utf-8'
ENCODING_OUTPUT_FILE = 'utf-8'
ENCODING_DATA_FILES  = 'utf-8'

DOWNLOAD_DIRECTORY_PREFIX = 'download_'
INFO_FILE_NAME = 'INFO.yaml'
UNZIP_DIRECTORY_NAME = 'download'

UNDERVOTE = -1
OVERVOTE  = -2

STATS_HEADER = """\
RCV RESULTS KEY

Total:         total number of ballots, including undervotes.

Voted:         number of ballots with at least one ranking marked (or overvoted).
Undervoted:    total minus voted.

N-Candidate:   number of voted ballots with N valid distinct candidate rankings.
               A valid ranking is a ranking not preceded by an overvote.
               For example, the 0-Distinct ballots are the first-round
               overvotes, i.e. the voted ballots whose first marked ranking
               is an overvote.

Has overvote:  number of ballots with an overvoted ranking at some ranking.
Has duplicate: number of ballots with the same candidate marked more than once.
Has skipped:   number of ballots with an unmarked ranking before a marked ranking.
Irregular:     number of voted ballots with at least one of the following:
               an overvote, a duplicate candidate, or a skipped ranking (see
               above for descriptions).  Note that these categories are not
               mutually exclusive, for example an unmarked ranking followed by
               an overvoted ranking.

R1-Overvotes:  number of ballots counting as an overvote in the first round.


"""

# TODO: overview of final round (percent of continuing first round, etc).
#       Include "adjusted final round percentage."
# TODO: html encode report.

def configure_logging(logging_level=None):
    """Configure logging for standard purposes.

    Args:
      logging_level: The minimum logging level to log.
                     Defaults to logging.INFO.

    """
    # If the stream does not define an "encoding" data attribute, the
    # logging module can throw an error like the following:
    #
    # Traceback (most recent call last):
    #   File "/System/Library/Frameworks/Python.framework/Versions/2.6/...
    #         lib/python2.6/logging/__init__.py", line 761, in emit
    #     self.stream.write(fs % msg.encode(self.stream.encoding))
    # LookupError: unknown encoding: unknown
    if logging_level is None:
        logging_level = logging.INFO

    # Create the handler.
    #
    # The stream is a file-like object to which to log.  The stream must
    # define an "encoding" data attribute, or else logging raises an error.
    stream = sys.stderr
    handler = logging.StreamHandler(stream)
    formatter = logging.Formatter("%(name)s: [%(levelname)s] %(message)s")
    handler.setFormatter(formatter)

    # The root logger.
    logger = logging.getLogger()

    logger.setLevel(logging_level)
    logger.addHandler(handler)

    _log.debug("Debug logging enabled.")


class DownloadMetadata(object):

    def __init__(self):
        self.url = ""
        self.iso_datetime_utc = ""
        self.iso_datetime_local = ""
        self.local_tzname = ""

    def _iso_to_datetime(self, iso_string):
        return datetime.strptime(iso_string, "%Y-%m-%dT%H:%M:%S")

    @property
    def datetime_utc(self):
        return self._iso_to_datetime(self.iso_datetime_utc)

    @datetime_utc.setter
    def datetime_utc(self, value):
        self.iso_datetime_utc = value.isoformat()

    @property
    def datetime_local(self):
        return self._iso_to_datetime(self.iso_datetime_local)

    @datetime_local.setter
    def datetime_local(self, value):
        self.iso_datetime_local = value.isoformat()


class BallotHandler(object):

    def __init__(self, contest, stats):
        """
        Construct an instance.

        """
        candidates = contest.candidate_ids
        winner = contest.winner_id
        finalists = contest.finalists
        non_winning_finalists = contest.non_winning_finalists

        self.analyzer = BallotAnalyzer(undervote=UNDERVOTE, overvote=OVERVOTE)
        self.stats = stats

        self.winner = winner
        self.set_of_finalists = set(finalists)
        self.non_winning_finalists = non_winning_finalists
        self.non_winners = list(set(candidates) - set([winner]))

    def on_ballot(self, ballot):
        """
        Update stats based on the given ballot.

        """
        analyzer = self.analyzer
        stats = self.stats
        winner = self.winner

        stats.total += 1

        first_round = analyzer.get_first_round(ballot)

        if first_round == UNDERVOTE:
            stats.undervotes += 1
            return

        set_of_validly_ranked = analyzer.get_set_of_validly_ranked(ballot)

        for candidate in set_of_validly_ranked:
            stats.validly_ranked[candidate] += 1

        if len(set_of_validly_ranked) == 3 and set_of_validly_ranked.isdisjoint(self.set_of_finalists):
            stats.truly_exhausted[first_round] += 1

        if first_round == OVERVOTE:
            stats.first_round_overvotes += 1
        else:
            number_ranked = len(set_of_validly_ranked)
            stats.add_number_ranked(first_round, number_ranked)
            if winner in set_of_validly_ranked:
                stats.ranked_winner[first_round] += 1
            if not set_of_validly_ranked.isdisjoint(self.set_of_finalists):
                stats.ranked_finalist[first_round] += 1
            else:
                # Then no finalist is validly ranked on the ballot.
                if OVERVOTE in ballot:
                    stats.exhausted_by_overvote += 1
            if analyzer.did_sweep(ballot, first_round):
                stats.did_sweep[first_round] += 1

            if analyzer.beats_challengers(ballot, winner, self.non_winning_finalists):
                stats.final_round_winner_total += 1

            # Calculate condorcet pairs against winner.
            for non_winner in self.non_winners:
                did_winner_win = analyzer.beats_challenger(ballot, winner, non_winner)
                if did_winner_win is None:
                    continue
                if did_winner_win:
                    stats.add_condorcet_winner(winner, non_winner)
                else:
                    stats.add_condorcet_winner(non_winner, winner)

        has_duplicate = False
        duplicate_count = analyzer.count_duplicates(ballot)
        if duplicate_count > 1:
            stats.duplicates[duplicate_count] += 1
            has_duplicate = True

        has_overvote = analyzer.has_overvote(ballot)
        has_skipped = analyzer.has_skipped(ballot)
    
        if has_overvote:
            stats.has_overvote += 1
        if has_skipped:
            stats.has_skipped += 1
        if has_overvote or has_duplicate or has_skipped:
            stats.irregular += 1


def unserialize_yaml_file(path):
    """
    Deserialize a value from disk.

    """
    with codecs.open(path, "r", encoding=ENCODING_INTERNAL) as stream:
        data = yaml.load(stream)

    return data


def ensure_dir(path):
    if os.path.isdir(path):
        return
    _log.info("Creating directory at: %s" % path)
    os.mkdir(path)


def write_to_file(s, path):
    """
    Write a unicode string to a file.

    """
    if not isinstance(s, unicode):
        raise Exception("The argument is not a unicode string.")

    _log.info("Creating file at: %s" % path)
    with codecs.open(path, "w", encoding=ENCODING_OUTPUT_FILE) as f:
        f.write(s)


def utc_datetime_to_local_datetime(utc_datetime):
    utc_tuple = utc_datetime.utctimetuple()
    timestamp = calendar.timegm(utc_tuple)
    local_datetime = datetime.fromtimestamp(timestamp)
    
    return local_datetime


def create_download_metadata(url, datetime_utc):
    """
    Return the dictionary of metadata about the election data downloaded.

    """
    # Stripping microseconds simplifies subsequent formatting code.
    datetime_utc = datetime_utc.replace(microsecond=0)

    datetime_local = utc_datetime_to_local_datetime(datetime_utc)
    local_tzname = "/".join(time.tzname) if time.tzname else ""

    data = DownloadMetadata()
    data.url = url
    data.datetime_utc = datetime_utc
    data.datetime_local = datetime_local
    data.local_tzname = local_tzname

    return data


def yaml_serialize(instance):
    """
    Serialize an object instance to a unicode YAML document.
    
    """
    return yaml.dump(instance.__dict__,  encoding=None, default_flow_style=False)


def download_data(url, contest_dir):
    """
    Download and extract the election zip file.
    
    """
    utc_now = datetime.utcnow()

    ensure_dir(contest_dir)
    readme_path = os.path.join(contest_dir, 'README.txt')
    write_to_file(u"This directory should be empty except for auto-downloaded directories.", readme_path)

    download_dir_name = DOWNLOAD_DIRECTORY_PREFIX + utc_now.strftime("%Y%m%d_%H%M%S")
    download_dir = os.path.join(contest_dir, download_dir_name)
    ensure_dir(download_dir)

    zip_path = os.path.join(download_dir, '%s%szip' % (UNZIP_DIRECTORY_NAME, os.extsep))
    
    _log.info("Downloading %s to %s..." % (url, zip_path))
    try:
        urllib.urlretrieve(url, zip_path)
    except Exception, ex:
        _log.error(ex)
        _log.error("Error downloading url: %s" % url)
        _log.info("Removing dir: %s" % download_dir)
        os.rmdir(download_dir)
        exit()

    unzip_dir = os.path.join(download_dir, UNZIP_DIRECTORY_NAME)
    zip_file = ZipFile(zip_path, 'r')
    zip_file.extractall(unzip_dir)

    metadata = create_download_metadata(url, utc_now)

    text = """\
# This file is auto-generated.  Do not modify this file.
# Date time strings are in ISO 8601 format YYYY-MM-DDTHH:MM:SS.
"""

    text += yaml_serialize(metadata)

    info_path = os.path.join(download_dir, INFO_FILE_NAME)
    write_to_file(text, info_path)


def most_recent_download_dir(contest_dir):

    file_name = DOWNLOAD_DIRECTORY_PREFIX + "*"
    glob_path = os.path.join(contest_dir, file_name)
    paths = glob.glob(glob_path)
    
    if not paths:
        raise Exception("Downloaded files not found in: %s" % contest_dir)

    paths.sort()

    return paths[-1]


def get_path(dir_path, file_glob):
    """
    Return the path in dir_path matching file_glob.

    """
    glob_path = os.path.join(dir_path, file_glob)
    paths = glob.glob(glob_path)
    
    if len(paths) < 1:
        raise AssertionError("No path found matching: %s" % glob_path)
    if len(paths) > 1:
        raise AssertionError("More than one path found matching: %s" % glob_path)

    return paths[0]


def get_data(election_label, contest_label, source, master_file_glob,
             ballot_file_glob, data_dir):
    """
    Download data if necessary, and return master and ballot paths.

    """
    ensure_dir(data_dir)

    election_dir = os.path.join(data_dir, election_label)
    ensure_dir(election_dir)

    contest_dir = os.path.join(election_dir, contest_label)

    if data_dir is not None:
        download_data(source, contest_dir)
        download_dir = most_recent_download_dir(contest_dir)

        _log.info("Using most recent download directory: %s" % download_dir)

        unzip_dir = os.path.join(download_dir, UNZIP_DIRECTORY_NAME)
        master_path = get_path(unzip_dir, master_file_glob)
        ballot_path = get_path(unzip_dir, ballot_file_glob)

    return master_path, ballot_path

def main(sys_argv):
    start_time = datetime.now()

    args = sys_argv[1:]

    path = args[0]
    data_dir = args[1] if len(args) > 1 else None

    configure_logging(logging.DEBUG)

    config = unserialize_yaml_file(path)

    election_label = config['election_label']
    election_name = config['election_name']
    election_source = config['source']
    master_file_glob = config['master_file_glob']
    ballot_file_glob = config['ballot_file_glob']

    reporter = Reporter(election_name=election_name.upper(), template_path='templates/report.mustache')

    for contest_config in config['contests']:

        contest_source = contest_config['source']
        contest_label = contest_config['label']
        winner = contest_config['winner']
        finalists = contest_config['finalists'] or None

        source = election_source + contest_source
        master_path, ballot_path = get_data(election_label, contest_label, source,
            master_file_glob, ballot_file_glob, data_dir)

        unzipped_dir = os.path.dirname(master_path)

        master_parser = MasterParser(ENCODING_DATA_FILES, winner, final_candidates=finalists)
        contest = master_parser.parse(master_path)

        stats = Stats(candidates=contest.candidate_ids, winner_id=contest.winner_id)
        ballot_handler = BallotHandler(contest, stats)

        # Parsing the ballot file is faster without specifying an encoding.
        # The ballot file is just integers, so an encoding is not necessary.
        parser = BallotParser(undervote=UNDERVOTE, overvote=OVERVOTE, on_ballot=ballot_handler.on_ballot)
        parser.process_contest(ballot_path, winner)

        info_path = os.path.join(unzipped_dir, os.pardir, INFO_FILE_NAME)
        
        download_dict = unserialize_yaml_file(info_path)

        download_metadata = DownloadMetadata()
        download_metadata.__dict__ = download_dict

        reporter.add_contest(contest_label, contest, stats, download_metadata=download_metadata)

    report = reporter.generate()

    try:
        print report
    except UnicodeEncodeError:
        # Windows seems to have trouble with some unicode characters, e.g. the "Ó" in GASCÓN.
        _log.warn("Error printing report to console (probably because of special characters.")

    output_path = "rcv_stats_%s.html" % election_label
    write_to_file(report, output_path)

    print "Completed in: %s" % (datetime.now() - start_time)


if __name__ == "__main__":
    main(sys.argv)
